// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/replicated_slave/grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_src_2freplicated_5fslave_2fgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_src_2freplicated_5fslave_2fgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_src_2freplicated_5fslave_2fgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto;
namespace metastore {
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class KV;
class KVDefaultTypeInternal;
extern KVDefaultTypeInternal _KV_default_instance_;
class KVCollection;
class KVCollectionDefaultTypeInternal;
extern KVCollectionDefaultTypeInternal _KVCollection_default_instance_;
class LockDataRefId;
class LockDataRefIdDefaultTypeInternal;
extern LockDataRefIdDefaultTypeInternal _LockDataRefId_default_instance_;
class ReadRequest;
class ReadRequestDefaultTypeInternal;
extern ReadRequestDefaultTypeInternal _ReadRequest_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class ValueRanged;
class ValueRangedDefaultTypeInternal;
extern ValueRangedDefaultTypeInternal _ValueRanged_default_instance_;
class WriteError;
class WriteErrorDefaultTypeInternal;
extern WriteErrorDefaultTypeInternal _WriteError_default_instance_;
class WriteRequest;
class WriteRequestDefaultTypeInternal;
extern WriteRequestDefaultTypeInternal _WriteRequest_default_instance_;
}  // namespace metastore
PROTOBUF_NAMESPACE_OPEN
template<> ::metastore::Empty* Arena::CreateMaybeMessage<::metastore::Empty>(Arena*);
template<> ::metastore::KV* Arena::CreateMaybeMessage<::metastore::KV>(Arena*);
template<> ::metastore::KVCollection* Arena::CreateMaybeMessage<::metastore::KVCollection>(Arena*);
template<> ::metastore::LockDataRefId* Arena::CreateMaybeMessage<::metastore::LockDataRefId>(Arena*);
template<> ::metastore::ReadRequest* Arena::CreateMaybeMessage<::metastore::ReadRequest>(Arena*);
template<> ::metastore::Value* Arena::CreateMaybeMessage<::metastore::Value>(Arena*);
template<> ::metastore::ValueRanged* Arena::CreateMaybeMessage<::metastore::ValueRanged>(Arena*);
template<> ::metastore::WriteError* Arena::CreateMaybeMessage<::metastore::WriteError>(Arena*);
template<> ::metastore::WriteRequest* Arena::CreateMaybeMessage<::metastore::WriteRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace metastore {

// ===================================================================

class LockDataRefId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.LockDataRefId) */ {
 public:
  inline LockDataRefId() : LockDataRefId(nullptr) {};
  virtual ~LockDataRefId();

  LockDataRefId(const LockDataRefId& from);
  LockDataRefId(LockDataRefId&& from) noexcept
    : LockDataRefId() {
    *this = ::std::move(from);
  }

  inline LockDataRefId& operator=(const LockDataRefId& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockDataRefId& operator=(LockDataRefId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LockDataRefId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockDataRefId* internal_default_instance() {
    return reinterpret_cast<const LockDataRefId*>(
               &_LockDataRefId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LockDataRefId& a, LockDataRefId& b) {
    a.Swap(&b);
  }
  inline void Swap(LockDataRefId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockDataRefId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockDataRefId* New() const final {
    return CreateMaybeMessage<LockDataRefId>(nullptr);
  }

  LockDataRefId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockDataRefId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LockDataRefId& from);
  void MergeFrom(const LockDataRefId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockDataRefId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.LockDataRefId";
  }
  protected:
  explicit LockDataRefId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:metastore.LockDataRefId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Empty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {};
  virtual ~Empty();

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:metastore.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ReadRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.ReadRequest) */ {
 public:
  inline ReadRequest() : ReadRequest(nullptr) {};
  virtual ~ReadRequest();

  ReadRequest(const ReadRequest& from);
  ReadRequest(ReadRequest&& from) noexcept
    : ReadRequest() {
    *this = ::std::move(from);
  }

  inline ReadRequest& operator=(const ReadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadRequest& operator=(ReadRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRequest* internal_default_instance() {
    return reinterpret_cast<const ReadRequest*>(
               &_ReadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReadRequest& a, ReadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadRequest* New() const final {
    return CreateMaybeMessage<ReadRequest>(nullptr);
  }

  ReadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadRequest& from);
  void MergeFrom(const ReadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.ReadRequest";
  }
  protected:
  explicit ReadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kTxnFieldNumber = 1,
  };
  // string key = 2;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .metastore.LockDataRefId txn = 1;
  bool has_txn() const;
  private:
  bool _internal_has_txn() const;
  public:
  void clear_txn();
  const ::metastore::LockDataRefId& txn() const;
  ::metastore::LockDataRefId* release_txn();
  ::metastore::LockDataRefId* mutable_txn();
  void set_allocated_txn(::metastore::LockDataRefId* txn);
  private:
  const ::metastore::LockDataRefId& _internal_txn() const;
  ::metastore::LockDataRefId* _internal_mutable_txn();
  public:
  void unsafe_arena_set_allocated_txn(
      ::metastore::LockDataRefId* txn);
  ::metastore::LockDataRefId* unsafe_arena_release_txn();

  // @@protoc_insertion_point(class_scope:metastore.ReadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::metastore::LockDataRefId* txn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class KV PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.KV) */ {
 public:
  inline KV() : KV(nullptr) {};
  virtual ~KV();

  KV(const KV& from);
  KV(KV&& from) noexcept
    : KV() {
    *this = ::std::move(from);
  }

  inline KV& operator=(const KV& from) {
    CopyFrom(from);
    return *this;
  }
  inline KV& operator=(KV&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KV* internal_default_instance() {
    return reinterpret_cast<const KV*>(
               &_KV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KV& a, KV& b) {
    a.Swap(&b);
  }
  inline void Swap(KV* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KV* New() const final {
    return CreateMaybeMessage<KV>(nullptr);
  }

  KV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KV>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KV& from);
  void MergeFrom(const KV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KV* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.KV";
  }
  protected:
  explicit KV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:metastore.KV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class WriteRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.WriteRequest) */ {
 public:
  inline WriteRequest() : WriteRequest(nullptr) {};
  virtual ~WriteRequest();

  WriteRequest(const WriteRequest& from);
  WriteRequest(WriteRequest&& from) noexcept
    : WriteRequest() {
    *this = ::std::move(from);
  }

  inline WriteRequest& operator=(const WriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteRequest& operator=(WriteRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WriteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteRequest* internal_default_instance() {
    return reinterpret_cast<const WriteRequest*>(
               &_WriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WriteRequest& a, WriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteRequest* New() const final {
    return CreateMaybeMessage<WriteRequest>(nullptr);
  }

  WriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WriteRequest& from);
  void MergeFrom(const WriteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.WriteRequest";
  }
  protected:
  explicit WriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnFieldNumber = 1,
    kKvFieldNumber = 2,
  };
  // .metastore.LockDataRefId txn = 1;
  bool has_txn() const;
  private:
  bool _internal_has_txn() const;
  public:
  void clear_txn();
  const ::metastore::LockDataRefId& txn() const;
  ::metastore::LockDataRefId* release_txn();
  ::metastore::LockDataRefId* mutable_txn();
  void set_allocated_txn(::metastore::LockDataRefId* txn);
  private:
  const ::metastore::LockDataRefId& _internal_txn() const;
  ::metastore::LockDataRefId* _internal_mutable_txn();
  public:
  void unsafe_arena_set_allocated_txn(
      ::metastore::LockDataRefId* txn);
  ::metastore::LockDataRefId* unsafe_arena_release_txn();

  // .metastore.KV kv = 2;
  bool has_kv() const;
  private:
  bool _internal_has_kv() const;
  public:
  void clear_kv();
  const ::metastore::KV& kv() const;
  ::metastore::KV* release_kv();
  ::metastore::KV* mutable_kv();
  void set_allocated_kv(::metastore::KV* kv);
  private:
  const ::metastore::KV& _internal_kv() const;
  ::metastore::KV* _internal_mutable_kv();
  public:
  void unsafe_arena_set_allocated_kv(
      ::metastore::KV* kv);
  ::metastore::KV* unsafe_arena_release_kv();

  // @@protoc_insertion_point(class_scope:metastore.WriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::metastore::LockDataRefId* txn_;
  ::metastore::KV* kv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.Value) */ {
 public:
  inline Value() : Value(nullptr) {};
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum ResCase {
    kVal = 1,
    kError = 2,
    RES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string val = 1;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  void set_val(const std::string& value);
  void set_val(std::string&& value);
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  std::string* mutable_val();
  std::string* release_val();
  void set_allocated_val(std::string* val);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_val();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_val(
      std::string* val);
  private:
  const std::string& _internal_val() const;
  void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // string error = 2;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_res();
  ResCase res_case() const;
  // @@protoc_insertion_point(class_scope:metastore.Value)
 private:
  class _Internal;
  void set_has_val();
  void set_has_error();

  inline bool has_res() const;
  inline void clear_has_res();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResUnion {
    ResUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  } res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class WriteError PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.WriteError) */ {
 public:
  inline WriteError() : WriteError(nullptr) {};
  virtual ~WriteError();

  WriteError(const WriteError& from);
  WriteError(WriteError&& from) noexcept
    : WriteError() {
    *this = ::std::move(from);
  }

  inline WriteError& operator=(const WriteError& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteError& operator=(WriteError&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WriteError& default_instance();

  enum ResCase {
    kError = 1,
    kOk = 2,
    RES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteError* internal_default_instance() {
    return reinterpret_cast<const WriteError*>(
               &_WriteError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WriteError& a, WriteError& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteError* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WriteError* New() const final {
    return CreateMaybeMessage<WriteError>(nullptr);
  }

  WriteError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WriteError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WriteError& from);
  void MergeFrom(const WriteError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.WriteError";
  }
  protected:
  explicit WriteError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // string error = 1;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string ok = 2;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const std::string& ok() const;
  void set_ok(const std::string& value);
  void set_ok(std::string&& value);
  void set_ok(const char* value);
  void set_ok(const char* value, size_t size);
  std::string* mutable_ok();
  std::string* release_ok();
  void set_allocated_ok(std::string* ok);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ok();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ok(
      std::string* ok);
  private:
  const std::string& _internal_ok() const;
  void _internal_set_ok(const std::string& value);
  std::string* _internal_mutable_ok();
  public:

  void clear_res();
  ResCase res_case() const;
  // @@protoc_insertion_point(class_scope:metastore.WriteError)
 private:
  class _Internal;
  void set_has_error();
  void set_has_ok();

  inline bool has_res() const;
  inline void clear_has_res();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResUnion {
    ResUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ok_;
  } res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class KVCollection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.KVCollection) */ {
 public:
  inline KVCollection() : KVCollection(nullptr) {};
  virtual ~KVCollection();

  KVCollection(const KVCollection& from);
  KVCollection(KVCollection&& from) noexcept
    : KVCollection() {
    *this = ::std::move(from);
  }

  inline KVCollection& operator=(const KVCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVCollection& operator=(KVCollection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KVCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVCollection* internal_default_instance() {
    return reinterpret_cast<const KVCollection*>(
               &_KVCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(KVCollection& a, KVCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(KVCollection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KVCollection* New() const final {
    return CreateMaybeMessage<KVCollection>(nullptr);
  }

  KVCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KVCollection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KVCollection& from);
  void MergeFrom(const KVCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVCollection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.KVCollection";
  }
  protected:
  explicit KVCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // repeated .metastore.KV val = 1;
  int val_size() const;
  private:
  int _internal_val_size() const;
  public:
  void clear_val();
  ::metastore::KV* mutable_val(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metastore::KV >*
      mutable_val();
  private:
  const ::metastore::KV& _internal_val(int index) const;
  ::metastore::KV* _internal_add_val();
  public:
  const ::metastore::KV& val(int index) const;
  ::metastore::KV* add_val();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metastore::KV >&
      val() const;

  // @@protoc_insertion_point(class_scope:metastore.KVCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metastore::KV > val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ValueRanged PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:metastore.ValueRanged) */ {
 public:
  inline ValueRanged() : ValueRanged(nullptr) {};
  virtual ~ValueRanged();

  ValueRanged(const ValueRanged& from);
  ValueRanged(ValueRanged&& from) noexcept
    : ValueRanged() {
    *this = ::std::move(from);
  }

  inline ValueRanged& operator=(const ValueRanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueRanged& operator=(ValueRanged&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValueRanged& default_instance();

  enum ResCase {
    kVal = 1,
    kError = 2,
    RES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueRanged* internal_default_instance() {
    return reinterpret_cast<const ValueRanged*>(
               &_ValueRanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ValueRanged& a, ValueRanged& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueRanged* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueRanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueRanged* New() const final {
    return CreateMaybeMessage<ValueRanged>(nullptr);
  }

  ValueRanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueRanged>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValueRanged& from);
  void MergeFrom(const ValueRanged& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueRanged* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "metastore.ValueRanged";
  }
  protected:
  explicit ValueRanged(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto);
    return ::descriptor_table_src_2freplicated_5fslave_2fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .metastore.KVCollection val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::metastore::KVCollection& val() const;
  ::metastore::KVCollection* release_val();
  ::metastore::KVCollection* mutable_val();
  void set_allocated_val(::metastore::KVCollection* val);
  private:
  const ::metastore::KVCollection& _internal_val() const;
  ::metastore::KVCollection* _internal_mutable_val();
  public:
  void unsafe_arena_set_allocated_val(
      ::metastore::KVCollection* val);
  ::metastore::KVCollection* unsafe_arena_release_val();

  // string error = 2;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  void clear_res();
  ResCase res_case() const;
  // @@protoc_insertion_point(class_scope:metastore.ValueRanged)
 private:
  class _Internal;
  void set_has_val();
  void set_has_error();

  inline bool has_res() const;
  inline void clear_has_res();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResUnion {
    ResUnion() {}
    ::metastore::KVCollection* val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  } res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_src_2freplicated_5fslave_2fgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LockDataRefId

// uint64 id = 1;
inline void LockDataRefId::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockDataRefId::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockDataRefId::id() const {
  // @@protoc_insertion_point(field_get:metastore.LockDataRefId.id)
  return _internal_id();
}
inline void LockDataRefId::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void LockDataRefId::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:metastore.LockDataRefId.id)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// ReadRequest

// .metastore.LockDataRefId txn = 1;
inline bool ReadRequest::_internal_has_txn() const {
  return this != internal_default_instance() && txn_ != nullptr;
}
inline bool ReadRequest::has_txn() const {
  return _internal_has_txn();
}
inline void ReadRequest::clear_txn() {
  if (GetArena() == nullptr && txn_ != nullptr) {
    delete txn_;
  }
  txn_ = nullptr;
}
inline const ::metastore::LockDataRefId& ReadRequest::_internal_txn() const {
  const ::metastore::LockDataRefId* p = txn_;
  return p != nullptr ? *p : *reinterpret_cast<const ::metastore::LockDataRefId*>(
      &::metastore::_LockDataRefId_default_instance_);
}
inline const ::metastore::LockDataRefId& ReadRequest::txn() const {
  // @@protoc_insertion_point(field_get:metastore.ReadRequest.txn)
  return _internal_txn();
}
inline void ReadRequest::unsafe_arena_set_allocated_txn(
    ::metastore::LockDataRefId* txn) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  txn_ = txn;
  if (txn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.ReadRequest.txn)
}
inline ::metastore::LockDataRefId* ReadRequest::release_txn() {
  auto temp = unsafe_arena_release_txn();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::metastore::LockDataRefId* ReadRequest::unsafe_arena_release_txn() {
  // @@protoc_insertion_point(field_release:metastore.ReadRequest.txn)
  
  ::metastore::LockDataRefId* temp = txn_;
  txn_ = nullptr;
  return temp;
}
inline ::metastore::LockDataRefId* ReadRequest::_internal_mutable_txn() {
  
  if (txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::metastore::LockDataRefId>(GetArena());
    txn_ = p;
  }
  return txn_;
}
inline ::metastore::LockDataRefId* ReadRequest::mutable_txn() {
  // @@protoc_insertion_point(field_mutable:metastore.ReadRequest.txn)
  return _internal_mutable_txn();
}
inline void ReadRequest::set_allocated_txn(::metastore::LockDataRefId* txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete txn_;
  }
  if (txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(txn);
    if (message_arena != submessage_arena) {
      txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:metastore.ReadRequest.txn)
}

// string key = 2;
inline void ReadRequest::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ReadRequest::key() const {
  // @@protoc_insertion_point(field_get:metastore.ReadRequest.key)
  return _internal_key();
}
inline void ReadRequest::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:metastore.ReadRequest.key)
}
inline std::string* ReadRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:metastore.ReadRequest.key)
  return _internal_mutable_key();
}
inline const std::string& ReadRequest::_internal_key() const {
  return key_.Get();
}
inline void ReadRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReadRequest::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.ReadRequest.key)
}
inline void ReadRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.ReadRequest.key)
}
inline void ReadRequest::set_key(const char* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.ReadRequest.key)
}
inline std::string* ReadRequest::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReadRequest::release_key() {
  // @@protoc_insertion_point(field_release:metastore.ReadRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReadRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:metastore.ReadRequest.key)
}
inline std::string* ReadRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.ReadRequest.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ReadRequest::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    
  } else {
    
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.ReadRequest.key)
}

// -------------------------------------------------------------------

// KV

// string key = 1;
inline void KV::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KV::key() const {
  // @@protoc_insertion_point(field_get:metastore.KV.key)
  return _internal_key();
}
inline void KV::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:metastore.KV.key)
}
inline std::string* KV::mutable_key() {
  // @@protoc_insertion_point(field_mutable:metastore.KV.key)
  return _internal_mutable_key();
}
inline const std::string& KV::_internal_key() const {
  return key_.Get();
}
inline void KV::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KV::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.KV.key)
}
inline void KV::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.KV.key)
}
inline void KV::set_key(const char* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.KV.key)
}
inline std::string* KV::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KV::release_key() {
  // @@protoc_insertion_point(field_release:metastore.KV.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KV::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:metastore.KV.key)
}
inline std::string* KV::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.KV.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void KV::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    
  } else {
    
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.KV.key)
}

// string value = 2;
inline void KV::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& KV::value() const {
  // @@protoc_insertion_point(field_get:metastore.KV.value)
  return _internal_value();
}
inline void KV::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:metastore.KV.value)
}
inline std::string* KV::mutable_value() {
  // @@protoc_insertion_point(field_mutable:metastore.KV.value)
  return _internal_mutable_value();
}
inline const std::string& KV::_internal_value() const {
  return value_.Get();
}
inline void KV::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void KV::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.KV.value)
}
inline void KV::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.KV.value)
}
inline void KV::set_value(const char* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.KV.value)
}
inline std::string* KV::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* KV::release_value() {
  // @@protoc_insertion_point(field_release:metastore.KV.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void KV::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:metastore.KV.value)
}
inline std::string* KV::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.KV.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void KV::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.KV.value)
}

// -------------------------------------------------------------------

// WriteRequest

// .metastore.LockDataRefId txn = 1;
inline bool WriteRequest::_internal_has_txn() const {
  return this != internal_default_instance() && txn_ != nullptr;
}
inline bool WriteRequest::has_txn() const {
  return _internal_has_txn();
}
inline void WriteRequest::clear_txn() {
  if (GetArena() == nullptr && txn_ != nullptr) {
    delete txn_;
  }
  txn_ = nullptr;
}
inline const ::metastore::LockDataRefId& WriteRequest::_internal_txn() const {
  const ::metastore::LockDataRefId* p = txn_;
  return p != nullptr ? *p : *reinterpret_cast<const ::metastore::LockDataRefId*>(
      &::metastore::_LockDataRefId_default_instance_);
}
inline const ::metastore::LockDataRefId& WriteRequest::txn() const {
  // @@protoc_insertion_point(field_get:metastore.WriteRequest.txn)
  return _internal_txn();
}
inline void WriteRequest::unsafe_arena_set_allocated_txn(
    ::metastore::LockDataRefId* txn) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_);
  }
  txn_ = txn;
  if (txn) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.WriteRequest.txn)
}
inline ::metastore::LockDataRefId* WriteRequest::release_txn() {
  auto temp = unsafe_arena_release_txn();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::metastore::LockDataRefId* WriteRequest::unsafe_arena_release_txn() {
  // @@protoc_insertion_point(field_release:metastore.WriteRequest.txn)
  
  ::metastore::LockDataRefId* temp = txn_;
  txn_ = nullptr;
  return temp;
}
inline ::metastore::LockDataRefId* WriteRequest::_internal_mutable_txn() {
  
  if (txn_ == nullptr) {
    auto* p = CreateMaybeMessage<::metastore::LockDataRefId>(GetArena());
    txn_ = p;
  }
  return txn_;
}
inline ::metastore::LockDataRefId* WriteRequest::mutable_txn() {
  // @@protoc_insertion_point(field_mutable:metastore.WriteRequest.txn)
  return _internal_mutable_txn();
}
inline void WriteRequest::set_allocated_txn(::metastore::LockDataRefId* txn) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete txn_;
  }
  if (txn) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(txn);
    if (message_arena != submessage_arena) {
      txn = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn, submessage_arena);
    }
    
  } else {
    
  }
  txn_ = txn;
  // @@protoc_insertion_point(field_set_allocated:metastore.WriteRequest.txn)
}

// .metastore.KV kv = 2;
inline bool WriteRequest::_internal_has_kv() const {
  return this != internal_default_instance() && kv_ != nullptr;
}
inline bool WriteRequest::has_kv() const {
  return _internal_has_kv();
}
inline void WriteRequest::clear_kv() {
  if (GetArena() == nullptr && kv_ != nullptr) {
    delete kv_;
  }
  kv_ = nullptr;
}
inline const ::metastore::KV& WriteRequest::_internal_kv() const {
  const ::metastore::KV* p = kv_;
  return p != nullptr ? *p : *reinterpret_cast<const ::metastore::KV*>(
      &::metastore::_KV_default_instance_);
}
inline const ::metastore::KV& WriteRequest::kv() const {
  // @@protoc_insertion_point(field_get:metastore.WriteRequest.kv)
  return _internal_kv();
}
inline void WriteRequest::unsafe_arena_set_allocated_kv(
    ::metastore::KV* kv) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv_);
  }
  kv_ = kv;
  if (kv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.WriteRequest.kv)
}
inline ::metastore::KV* WriteRequest::release_kv() {
  auto temp = unsafe_arena_release_kv();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::metastore::KV* WriteRequest::unsafe_arena_release_kv() {
  // @@protoc_insertion_point(field_release:metastore.WriteRequest.kv)
  
  ::metastore::KV* temp = kv_;
  kv_ = nullptr;
  return temp;
}
inline ::metastore::KV* WriteRequest::_internal_mutable_kv() {
  
  if (kv_ == nullptr) {
    auto* p = CreateMaybeMessage<::metastore::KV>(GetArena());
    kv_ = p;
  }
  return kv_;
}
inline ::metastore::KV* WriteRequest::mutable_kv() {
  // @@protoc_insertion_point(field_mutable:metastore.WriteRequest.kv)
  return _internal_mutable_kv();
}
inline void WriteRequest::set_allocated_kv(::metastore::KV* kv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kv_;
  }
  if (kv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kv);
    if (message_arena != submessage_arena) {
      kv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:metastore.WriteRequest.kv)
}

// -------------------------------------------------------------------

// Value

// string val = 1;
inline bool Value::_internal_has_val() const {
  return res_case() == kVal;
}
inline void Value::set_has_val() {
  _oneof_case_[0] = kVal;
}
inline void Value::clear_val() {
  if (_internal_has_val()) {
    res_.val_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_res();
  }
}
inline const std::string& Value::val() const {
  // @@protoc_insertion_point(field_get:metastore.Value.val)
  return _internal_val();
}
inline void Value::set_val(const std::string& value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:metastore.Value.val)
}
inline std::string* Value::mutable_val() {
  // @@protoc_insertion_point(field_mutable:metastore.Value.val)
  return _internal_mutable_val();
}
inline const std::string& Value::_internal_val() const {
  if (_internal_has_val()) {
    return res_.val_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_val(const std::string& value) {
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_val(std::string&& value) {
  // @@protoc_insertion_point(field_set:metastore.Value.val)
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.val_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.Value.val)
}
inline void Value::set_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.Value.val)
}
inline void Value::set_val(const char* value,
                             size_t size) {
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.val_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.Value.val)
}
inline std::string* Value::_internal_mutable_val() {
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return res_.val_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_val() {
  // @@protoc_insertion_point(field_release:metastore.Value.val)
  if (_internal_has_val()) {
    clear_has_res();
    return res_.val_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_val(std::string* val) {
  if (has_res()) {
    clear_res();
  }
  if (val != nullptr) {
    set_has_val();
    res_.val_.UnsafeSetDefault(val);
  }
  // @@protoc_insertion_point(field_set_allocated:metastore.Value.val)
}
inline std::string* Value::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.Value.val)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_val()) {
    clear_has_res();
    return res_.val_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_val(std::string* val) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_val()) {
    res_.val_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_res();
  if (val) {
    set_has_val();
    res_.val_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), val, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.Value.val)
}

// string error = 2;
inline bool Value::_internal_has_error() const {
  return res_case() == kError;
}
inline void Value::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Value::clear_error() {
  if (_internal_has_error()) {
    res_.error_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_res();
  }
}
inline const std::string& Value::error() const {
  // @@protoc_insertion_point(field_get:metastore.Value.error)
  return _internal_error();
}
inline void Value::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:metastore.Value.error)
}
inline std::string* Value::mutable_error() {
  // @@protoc_insertion_point(field_mutable:metastore.Value.error)
  return _internal_mutable_error();
}
inline const std::string& Value::_internal_error() const {
  if (_internal_has_error()) {
    return res_.error_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Value::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Value::set_error(std::string&& value) {
  // @@protoc_insertion_point(field_set:metastore.Value.error)
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.Value.error)
}
inline void Value::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.Value.error)
}
inline void Value::set_error(const char* value,
                             size_t size) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.Value.error)
}
inline std::string* Value::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return res_.error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Value::release_error() {
  // @@protoc_insertion_point(field_release:metastore.Value.error)
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::set_allocated_error(std::string* error) {
  if (has_res()) {
    clear_res();
  }
  if (error != nullptr) {
    set_has_error();
    res_.error_.UnsafeSetDefault(error);
  }
  // @@protoc_insertion_point(field_set_allocated:metastore.Value.error)
}
inline std::string* Value::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.Value.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_error(std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_error()) {
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_res();
  if (error) {
    set_has_error();
    res_.error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.Value.error)
}

inline bool Value::has_res() const {
  return res_case() != RES_NOT_SET;
}
inline void Value::clear_has_res() {
  _oneof_case_[0] = RES_NOT_SET;
}
inline Value::ResCase Value::res_case() const {
  return Value::ResCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteError

// string error = 1;
inline bool WriteError::_internal_has_error() const {
  return res_case() == kError;
}
inline void WriteError::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void WriteError::clear_error() {
  if (_internal_has_error()) {
    res_.error_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_res();
  }
}
inline const std::string& WriteError::error() const {
  // @@protoc_insertion_point(field_get:metastore.WriteError.error)
  return _internal_error();
}
inline void WriteError::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:metastore.WriteError.error)
}
inline std::string* WriteError::mutable_error() {
  // @@protoc_insertion_point(field_mutable:metastore.WriteError.error)
  return _internal_mutable_error();
}
inline const std::string& WriteError::_internal_error() const {
  if (_internal_has_error()) {
    return res_.error_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void WriteError::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WriteError::set_error(std::string&& value) {
  // @@protoc_insertion_point(field_set:metastore.WriteError.error)
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.WriteError.error)
}
inline void WriteError::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.WriteError.error)
}
inline void WriteError::set_error(const char* value,
                             size_t size) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.WriteError.error)
}
inline std::string* WriteError::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return res_.error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WriteError::release_error() {
  // @@protoc_insertion_point(field_release:metastore.WriteError.error)
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void WriteError::set_allocated_error(std::string* error) {
  if (has_res()) {
    clear_res();
  }
  if (error != nullptr) {
    set_has_error();
    res_.error_.UnsafeSetDefault(error);
  }
  // @@protoc_insertion_point(field_set_allocated:metastore.WriteError.error)
}
inline std::string* WriteError::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.WriteError.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void WriteError::unsafe_arena_set_allocated_error(std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_error()) {
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_res();
  if (error) {
    set_has_error();
    res_.error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.WriteError.error)
}

// string ok = 2;
inline bool WriteError::_internal_has_ok() const {
  return res_case() == kOk;
}
inline void WriteError::set_has_ok() {
  _oneof_case_[0] = kOk;
}
inline void WriteError::clear_ok() {
  if (_internal_has_ok()) {
    res_.ok_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_res();
  }
}
inline const std::string& WriteError::ok() const {
  // @@protoc_insertion_point(field_get:metastore.WriteError.ok)
  return _internal_ok();
}
inline void WriteError::set_ok(const std::string& value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:metastore.WriteError.ok)
}
inline std::string* WriteError::mutable_ok() {
  // @@protoc_insertion_point(field_mutable:metastore.WriteError.ok)
  return _internal_mutable_ok();
}
inline const std::string& WriteError::_internal_ok() const {
  if (_internal_has_ok()) {
    return res_.ok_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void WriteError::_internal_set_ok(const std::string& value) {
  if (!_internal_has_ok()) {
    clear_res();
    set_has_ok();
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.ok_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WriteError::set_ok(std::string&& value) {
  // @@protoc_insertion_point(field_set:metastore.WriteError.ok)
  if (!_internal_has_ok()) {
    clear_res();
    set_has_ok();
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.ok_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.WriteError.ok)
}
inline void WriteError::set_ok(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_ok()) {
    clear_res();
    set_has_ok();
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.ok_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.WriteError.ok)
}
inline void WriteError::set_ok(const char* value,
                             size_t size) {
  if (!_internal_has_ok()) {
    clear_res();
    set_has_ok();
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.ok_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.WriteError.ok)
}
inline std::string* WriteError::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_res();
    set_has_ok();
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return res_.ok_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WriteError::release_ok() {
  // @@protoc_insertion_point(field_release:metastore.WriteError.ok)
  if (_internal_has_ok()) {
    clear_has_res();
    return res_.ok_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void WriteError::set_allocated_ok(std::string* ok) {
  if (has_res()) {
    clear_res();
  }
  if (ok != nullptr) {
    set_has_ok();
    res_.ok_.UnsafeSetDefault(ok);
  }
  // @@protoc_insertion_point(field_set_allocated:metastore.WriteError.ok)
}
inline std::string* WriteError::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.WriteError.ok)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_ok()) {
    clear_has_res();
    return res_.ok_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void WriteError::unsafe_arena_set_allocated_ok(std::string* ok) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_ok()) {
    res_.ok_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_res();
  if (ok) {
    set_has_ok();
    res_.ok_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ok, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.WriteError.ok)
}

inline bool WriteError::has_res() const {
  return res_case() != RES_NOT_SET;
}
inline void WriteError::clear_has_res() {
  _oneof_case_[0] = RES_NOT_SET;
}
inline WriteError::ResCase WriteError::res_case() const {
  return WriteError::ResCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// KVCollection

// repeated .metastore.KV val = 1;
inline int KVCollection::_internal_val_size() const {
  return val_.size();
}
inline int KVCollection::val_size() const {
  return _internal_val_size();
}
inline void KVCollection::clear_val() {
  val_.Clear();
}
inline ::metastore::KV* KVCollection::mutable_val(int index) {
  // @@protoc_insertion_point(field_mutable:metastore.KVCollection.val)
  return val_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metastore::KV >*
KVCollection::mutable_val() {
  // @@protoc_insertion_point(field_mutable_list:metastore.KVCollection.val)
  return &val_;
}
inline const ::metastore::KV& KVCollection::_internal_val(int index) const {
  return val_.Get(index);
}
inline const ::metastore::KV& KVCollection::val(int index) const {
  // @@protoc_insertion_point(field_get:metastore.KVCollection.val)
  return _internal_val(index);
}
inline ::metastore::KV* KVCollection::_internal_add_val() {
  return val_.Add();
}
inline ::metastore::KV* KVCollection::add_val() {
  // @@protoc_insertion_point(field_add:metastore.KVCollection.val)
  return _internal_add_val();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::metastore::KV >&
KVCollection::val() const {
  // @@protoc_insertion_point(field_list:metastore.KVCollection.val)
  return val_;
}

// -------------------------------------------------------------------

// ValueRanged

// .metastore.KVCollection val = 1;
inline bool ValueRanged::_internal_has_val() const {
  return res_case() == kVal;
}
inline bool ValueRanged::has_val() const {
  return _internal_has_val();
}
inline void ValueRanged::set_has_val() {
  _oneof_case_[0] = kVal;
}
inline void ValueRanged::clear_val() {
  if (_internal_has_val()) {
    if (GetArena() == nullptr) {
      delete res_.val_;
    }
    clear_has_res();
  }
}
inline ::metastore::KVCollection* ValueRanged::release_val() {
  // @@protoc_insertion_point(field_release:metastore.ValueRanged.val)
  if (_internal_has_val()) {
    clear_has_res();
      ::metastore::KVCollection* temp = res_.val_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    res_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::metastore::KVCollection& ValueRanged::_internal_val() const {
  return _internal_has_val()
      ? *res_.val_
      : *reinterpret_cast< ::metastore::KVCollection*>(&::metastore::_KVCollection_default_instance_);
}
inline const ::metastore::KVCollection& ValueRanged::val() const {
  // @@protoc_insertion_point(field_get:metastore.ValueRanged.val)
  return _internal_val();
}
inline ::metastore::KVCollection* ValueRanged::unsafe_arena_release_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.ValueRanged.val)
  if (_internal_has_val()) {
    clear_has_res();
    ::metastore::KVCollection* temp = res_.val_;
    res_.val_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ValueRanged::unsafe_arena_set_allocated_val(::metastore::KVCollection* val) {
  clear_res();
  if (val) {
    set_has_val();
    res_.val_ = val;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.ValueRanged.val)
}
inline ::metastore::KVCollection* ValueRanged::_internal_mutable_val() {
  if (!_internal_has_val()) {
    clear_res();
    set_has_val();
    res_.val_ = CreateMaybeMessage< ::metastore::KVCollection >(GetArena());
  }
  return res_.val_;
}
inline ::metastore::KVCollection* ValueRanged::mutable_val() {
  // @@protoc_insertion_point(field_mutable:metastore.ValueRanged.val)
  return _internal_mutable_val();
}

// string error = 2;
inline bool ValueRanged::_internal_has_error() const {
  return res_case() == kError;
}
inline void ValueRanged::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void ValueRanged::clear_error() {
  if (_internal_has_error()) {
    res_.error_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_res();
  }
}
inline const std::string& ValueRanged::error() const {
  // @@protoc_insertion_point(field_get:metastore.ValueRanged.error)
  return _internal_error();
}
inline void ValueRanged::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:metastore.ValueRanged.error)
}
inline std::string* ValueRanged::mutable_error() {
  // @@protoc_insertion_point(field_mutable:metastore.ValueRanged.error)
  return _internal_mutable_error();
}
inline const std::string& ValueRanged::_internal_error() const {
  if (_internal_has_error()) {
    return res_.error_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ValueRanged::_internal_set_error(const std::string& value) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValueRanged::set_error(std::string&& value) {
  // @@protoc_insertion_point(field_set:metastore.ValueRanged.error)
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:metastore.ValueRanged.error)
}
inline void ValueRanged::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:metastore.ValueRanged.error)
}
inline void ValueRanged::set_error(const char* value,
                             size_t size) {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  res_.error_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:metastore.ValueRanged.error)
}
inline std::string* ValueRanged::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return res_.error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValueRanged::release_error() {
  // @@protoc_insertion_point(field_release:metastore.ValueRanged.error)
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ValueRanged::set_allocated_error(std::string* error) {
  if (has_res()) {
    clear_res();
  }
  if (error != nullptr) {
    set_has_error();
    res_.error_.UnsafeSetDefault(error);
  }
  // @@protoc_insertion_point(field_set_allocated:metastore.ValueRanged.error)
}
inline std::string* ValueRanged::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:metastore.ValueRanged.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_error()) {
    clear_has_res();
    return res_.error_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ValueRanged::unsafe_arena_set_allocated_error(std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_error()) {
    res_.error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_res();
  if (error) {
    set_has_error();
    res_.error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:metastore.ValueRanged.error)
}

inline bool ValueRanged::has_res() const {
  return res_case() != RES_NOT_SET;
}
inline void ValueRanged::clear_has_res() {
  _oneof_case_[0] = RES_NOT_SET;
}
inline ValueRanged::ResCase ValueRanged::res_case() const {
  return ValueRanged::ResCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace metastore

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_src_2freplicated_5fslave_2fgrpc_2eproto
